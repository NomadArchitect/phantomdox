=========================
Phantom Language Compiler
=========================

Structure and implementation details of the Phantom OS
compiler (*PLC*).

Basis of native Phantom OS personality is a bytecode
virtual machine, which, integrated with persistent memory
subsystem guarantees Phantom's ability to restart running
application code after OS restart.

PLC supports two modes of operation. It can work as a 
complete compiler (and process source files written in
Phantom language), or can be a backend for another compiler.

There are two language support projects currently in progress.

First one is translator for Java class files which is intended
to support not only Java language, but also all languages that
are able to work on top of JVM, such as Kotlin, Scala, ...

.. TODO add languages

Second one is translator for Python language. It is based
on Python parser written in Python and generating intermediate
file which is read by PLC and used as input for PLC code generator.


--------------
Compiler input
--------------

There are three input paths for compiler at the current moment.

* Parser for the Phantom language - this one is production level
* Loader of JVM class files - basic implementation, incomplete
* Connector for Python AST - work in progress

Phantom language parser
-----------------------

Parser processes source code and builds tree (AST) of ``Node`` objects which
represent program in form of (operation (operand) (operand)), where operand
is possibly operation too. 

.. TODO write more

Java class file loader
----------------------

Loads .class files, reads bytecode, rebuilts JVM-style AST, then converts it
to Phantom's AST tree, similar to one generated by parser, as described in
`Phantom language parser`_.

.. TODO write more

Python frontend connector
-------------------------

Loads special intermediate file which is generated by Python language parser
and resembles AST, but has more linear structure.

.. TODO write more

-----------------
Compiler pipeline
-----------------

Process of compilation is divided into the following phases:

* Loading of root classes: .internal.int, internal.string, .internal.class, etc
* Parsing of source file, loading JVM .class, loading other frontend AST
* Loading imported classes
* Preprocessing void status
* Deciding on ordinals
* Finding node types
* Preprocessing nodes
* Generation bytecode
* Generating additional output files (.lst, .lstc, .d, etc)


Code tree prerprocessing
------------------------

Preprocessing is broken down in a set of phases. Each phase walks 
down the tree usually processing children before parent is processed.

Preprocessing void status
^^^^^^^^^^^^^^^^^^^^^^^^^

The goal of this phase is to find out if outer node needs value of inner one.
The case when it is true is a code like ``a = (b = c)``, where assignment node
for ``b = c`` part still has to return a copy of assigned value for outer
``a = (...)`` node.

.. TODO funcs called and state changed

Deciding on ordinals
^^^^^^^^^^^^^^^^^^^^

Current implemenation of compiler assigns method numbers and field positions
in objects at compile time. That will change later (OS instance will assign
ordinal numbers for all the methods and fields), but now compiler has to
do it during preprocessing.

Finding node types
^^^^^^^^^^^^^^^^^^

At this phase compiler finds out returning type for each node.
Note that this affects code generation in terms of at which stack
operations will be executed.

Preprocessing nodes
^^^^^^^^^^^^^^^^^^^

There is a lot of specific preprocessing in each kind of node,
but generally it includes deciding on which stack operation is performed,
and whether it needs type conversion, both for numeric types and for 
objects.

Bytecode generation
-------------------

This phase is usually quite trivial, because previous phases found out
all the relevant information.



------------------
Phantom class file
------------------

Phantom class file is a simple tagged containers sequence. Each container 
(file *record*) has type, size and contents. Class file contains just 
one class.

.. TODO reference to WIKI?


